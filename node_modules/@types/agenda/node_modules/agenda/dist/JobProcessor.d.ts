import type { AgendaStatus } from './types/AgendaStatus.js';
import type { Agenda, JobWithId } from './index.js';
import type { NotificationChannel } from './types/NotificationChannel.js';
import type { DrainOptions, DrainResult } from './types/DrainOptions.js';
/**
 * @class
 * Process methods for jobs
 */
export declare class JobProcessor {
    private agenda;
    private maxConcurrency;
    private totalLockLimit;
    private processEvery;
    private jobStatus;
    private localQueueProcessing;
    getStatus(fullDetails?: boolean): Promise<AgendaStatus>;
    private nextScanAt;
    private jobQueue;
    private runningJobs;
    private lockedJobs;
    private isJobQueueFilling;
    private isRunning;
    private processInterval?;
    private notificationChannel?;
    private notificationUnsubscribe?;
    constructor(agenda: Agenda, maxConcurrency: number, totalLockLimit: number, processEvery: number, notificationChannel?: NotificationChannel);
    stop(): JobWithId[];
    /**
     * Waits for all currently running jobs to finish, then stops the processor.
     * Unlike stop(), this method does not immediately return - it waits for graceful completion.
     * @param options - Optional timeout or AbortSignal, or timeout number directly
     * @returns Promise that resolves with drain result when complete, timed out, or aborted
     */
    drain(options?: number | DrainOptions): Promise<DrainResult>;
    /**
     * Handle incoming job notification - triggers immediate processing
     */
    private handleNotification;
    process(): Promise<void>;
    /**
     * Returns true if a job of the specified name can be locked.
     * Considers maximum locked jobs at any time if self._lockLimit is > 0
     * Considers maximum locked jobs of the specified name at any time if jobDefinition.lockLimit is > 0
     * @param {String} name name of job to check if we should lock or not
     * @returns {boolean} whether or not you should lock job
     */
    shouldLock(name: string): boolean;
    /**
     * Internal method that adds a job to be processed to the local queue
     * @param job - Job to enqueue
     */
    private enqueueJob;
    private findAndLockNextJob;
    /**
     * Internal method used to fill a queue with jobs that can be run
     * @param {String} name fill a queue with specific job name
     * @returns {undefined}
     */
    private jobQueueFilling;
    /**
     * Internal method that processes any jobs in the local queue (array)
     * handledJobs keeps list of already processed jobs
     * @returns {undefined}
     */
    private jobProcessing;
    /**
     * Internal method that tries to run a job and if it fails, retries again!
     * @returns {boolean} processed a job or not
     */
    private runOrRetry;
    private updateStatus;
}
