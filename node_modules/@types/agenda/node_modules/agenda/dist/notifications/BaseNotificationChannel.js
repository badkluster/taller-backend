import { EventEmitter } from 'events';
/**
 * Abstract base class for notification channels.
 * Provides common functionality like state management and reconnection logic.
 */
export class BaseNotificationChannel extends EventEmitter {
    _state = 'disconnected';
    handlers = new Set();
    stateHandlers = new Set();
    reconnectAttempts = 0;
    reconnectTimeout;
    config;
    constructor(config = {}) {
        super();
        this.config = {
            channelName: config.channelName ?? 'agenda:jobs',
            reconnect: {
                enabled: config.reconnect?.enabled ?? true,
                maxAttempts: config.reconnect?.maxAttempts ?? 10,
                initialDelayMs: config.reconnect?.initialDelayMs ?? 100,
                maxDelayMs: config.reconnect?.maxDelayMs ?? 30000
            }
        };
    }
    get state() {
        return this._state;
    }
    setState(newState) {
        if (this._state !== newState) {
            this._state = newState;
            this.emit('stateChange', newState);
        }
    }
    subscribe(handler) {
        this.handlers.add(handler);
        return () => {
            this.handlers.delete(handler);
        };
    }
    async notifyHandlers(notification) {
        const promises = [];
        for (const handler of this.handlers) {
            try {
                const result = handler(notification);
                if (result instanceof Promise) {
                    promises.push(result);
                }
            }
            catch (error) {
                this.emit('error', error);
            }
        }
        await Promise.allSettled(promises);
    }
    /**
     * Notify all registered state handlers of a state notification.
     * Subclasses should call this when receiving state notifications.
     */
    async notifyStateHandlers(notification) {
        const promises = [];
        for (const handler of this.stateHandlers) {
            try {
                const result = handler(notification);
                if (result instanceof Promise) {
                    promises.push(result);
                }
            }
            catch (error) {
                this.emit('error', error);
            }
        }
        await Promise.allSettled(promises);
    }
    /**
     * Subscribe to state notifications.
     * Default implementation manages the stateHandlers set.
     */
    subscribeState(handler) {
        this.stateHandlers.add(handler);
        return () => {
            this.stateHandlers.delete(handler);
        };
    }
    scheduleReconnect() {
        if (!this.config.reconnect.enabled) {
            return;
        }
        if (this.reconnectAttempts >= this.config.reconnect.maxAttempts) {
            this.setState('error');
            this.emit('error', new Error('Max reconnection attempts reached'));
            return;
        }
        const delay = Math.min(this.config.reconnect.initialDelayMs * Math.pow(2, this.reconnectAttempts), this.config.reconnect.maxDelayMs);
        this.setState('reconnecting');
        this.reconnectAttempts++;
        this.reconnectTimeout = setTimeout(() => {
            this.connect().catch(error => {
                this.emit('error', error);
            });
        }, delay);
    }
    clearReconnect() {
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = undefined;
        }
        this.reconnectAttempts = 0;
    }
}
//# sourceMappingURL=BaseNotificationChannel.js.map